<link rel="import" href="../polymer/polymer.html">

<!--
`aws-dynamodb`
Polymer Web Component for AWS DynamoDB
-->

<dom-module id="aws-dynamodb">
  <script>
    (function () {
      'use strict';

// @todo:
// - option to override region (because of endpoint)?
// - add readonly option to prevent writing on binding?
// - limit and offset

      /**
       * The `aws-dynamodb` element is an easy way to retrieve and update
       * AWS DynamoDB data.
       *
       * Example usage:
       *
       * ```html
       * <aws-app
       *      region="eu-west-1">
       * </aws-app>
       * <aws-dynamodb
       *      table-name="notes"
       *      data="{{data}}">
       * </aws-dynamodb>
       * ```
       *
       * The 'aws-dynamodb' element initializes `AWS` in `aws-dynamodb`.
       */
      Polymer({
        is: 'aws-dynamodb',

        properties: {
          /**
           * Conditions to use when requesting data
           *
           * This array should contain all attributes with their value and condition as objects.
           *
           * The structure of a `condition` is as follows:
           *
           * ```javascript
           * [{
           *   title: {
           *     condition: '=',
           *     value: 'Test Note #1'
           *   }
           * }]
           * ```
           *
           * Valid conditions are: `=, <, <=, >, >=, begins_with`
           */
          conditions: {
            type: Array,
            value: []
          },

          /**
           * Whether to use consistent reads or not
           *
           * By default the operations will use eventually consistent reads; therefore,
           * the result set might not include the changes to data in the table immediatly
           * before the operation began.
           *
           * Note: global secondary indexes do not support consistent reads, so do not
           * specify consistentRead when querying a global secondary index.
           */
          consistentRead: {
            type: Boolean,
            value: false
          },

          /**
           * Operation's response
           *
           * This will be update every time the operation or query changes, changes
           * to this object will result in updates inside the database
           */
          data: {
            type: Object,
            notify: true
          },

          /**
           * Whether data response data should be parsed or not
           *
           * If this is true the returned data will not contain the attribute types:
           * `S, N, B, SS, NS, BS, M, L, NULL, BOOL`.
           */
          formatData: {
            type: Boolean,
            value: false
          },

          /**
           * The secondary index to scan or query
           *
           * If this is not specified the query will use the primary index of the
           * table.
           */
          indexName: {
            type: String,
            value: ''
          },

          /**
           * The maximum number of records to retrieve for a scan or query
           */
          limit: {
            type: Number,
            value: 100
          },

          /**
           * The operation which is used for getting items from the DynamoDB
           *
           * The only accepted values are `scan` and `query`.
           *
           * Note: if the query operation is used, at least one condition must be set.
           */
          operation: {
            type: String,
            value: 'scan',
            observer: '_getData'
          },

          /**
           * Specify the order for index traversal
           *
           * If `true`, the traversal is performed in descending order.
           */
          reverseOrder: {
            type: Boolean,
            value: false
          },

          /**
           * The name of the DynamoDB Table
           *
           * For example: 'notes'
           */
          tableName: {
            type: String,
            value: ''
          },

          _dynamoDBRef: {
            type: Object,
            observer: '_getData'
          },

          _lastEvaluatedKey: {
            type: Object
          },

          _params: {
            type: Object
          }
        },

        observers: [
          '_computeParams(tableName, limit, reverseOrder, indexName, conditions)'
        ],

        attached: function() {
          this._dynamoDBRef = new AWS.DynamoDB();
        },

        /**
         * Adds the record to the table
         *
         * @param   {Object} record The record that should be added to the table.
         */
        addRecord: function(record) {
// @todo: implement
        },

        /**
         * Load the next page of results
         *
         * There is no previousPage functionality, it is advisable to cache the
         * previous results locally.
         *
         * @return  {Boolean} Boolean being true if the next page will be loaded
         * and false if there is no next page.
         */
        nextPage: function() {
          if (this._lastEvaluatedKey !== null) {
            this.set('_params.ExclusiveStartKey', this._lastEvaluatedKey);
            this._getData();
            return true;
          } else {
            return false;
          }
        },

        /**
         * Updates the given record in the table
         *
         * @param   {Number} index The index of the record in the table.
         * @param   {Object} record The updated record.
         */
        updateRecord: function(index, record) {
// @todo: implement
        },

        _computeParams: function(table, limit, traversal, index, conditions) {
          if (table !== '') {
            this.set('_params', {
              ConsistentRead: this.consistentRead,
              Limit: limit,
              ScanIndexForward: !traversal,
              TableName: table
            });

            if (index !== '') {
              this.set('_params.IndexName', index);
            }

            if (conditions.length > 0) {
              var computedConditionParams = this._generateConditionParams(conditions);
              this.set('_params.ExpressionAttributeNames', computedConditionParams.names);
              this.set('_params.ExpressionAttributeValues', computedConditionParams.values);
              this.set('_params.KeyConditionExpression', computedConditionParams.expression);
            }

            if (this._isOperationValid(this.operation)) {
              this._getData();
            }
          }
        },

        _generateConditionParams: function(conditions) {
          var conditionParams = {
            names: {},
            values: {},
            expression: ''
          };
          var key;
          var name;
          var value;
          var condition;

          for (var item in conditions) {
            condition = conditions[item];
            key = Object.keys(condition)[0];

            if (!condition[key].value || !condition[key].condition) {
              break;
            }

            name = '#' + key;
            value = ':' + key;
            conditionParams.names[name] = key;

            // Determine the value type
            switch (typeof condition[key].value) {
              case 'array':
                conditionParams.values[value] = { L: condition[key].value };
                break;
              case 'object':
                conditionParams.values[value] = { M: condition[key].value };
                break;
              case 'string':
                conditionParams.values[value] = { S: condition[key].value.toString() };
                break;
              case 'number':
                conditionParams.values[value] = { N: condition[key].value.toString() };
                break;
              case 'boolean':
                conditionParams.values[value] = { BOOL: condition[key].value };
                break;
            }

            conditionParams.expression += name + ' ' + condition[key].condition + ' ' + value + ', ';
          }

          // Remove the last comma
          conditionParams.expression = conditionParams.expression.slice(0, -2);

          return conditionParams;
        },

        _getData: function() {
          if (!this._isOperationValid(this.operation)) {
            throw new Error('Operation `' + this.operation + '` is not a valid operation');
          }

          if (this._dynamoDBRef && this._params) {
            this._dynamoDBRef[this.operation](
              this._params,
              this._handleResponse.bind(this)
            );
          }
        },

        _handleResponse: function(error, data) {
          if (error) {
            throw new Error('Could not retrieve data from DynamoDB because: ' + error);
          }

          this.set('_lastEvaluatedKey', data.LastEvaluatedKey);

          if (this.formatData) {
            for (var i = 0, length = data.Items.length; i < length; i++) {
              data.Items[i] = this._parseItem(data.Items[i]);
            }

            this.set('data', data.Items);
          } else {
            this.set('data', data.Items);
          }
        },

        _isOperationValid: function(operation) {
          return operation === 'scan' || operation === 'query';
        },

        // http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_AttributeValue.html
        _parseItem: function(item) {
          var parsed = {};

          for (var j in item) {
            var type = Object.keys(item[j])[0];
            parsed[j] = item[j][type];

            if (type === 'N') {
              parsed[j] = parseFloat(item[j].N);
            }

            if (type === 'BOOL') {
              if (item[j].BOOL === 'true' || item[j].BOOL === true) {
                parsed[j] = true;
              } else {
                parsed[j] = false;
              }
            }
          }

          return parsed;
        }
      });
    })();
  </script>
</dom-module>